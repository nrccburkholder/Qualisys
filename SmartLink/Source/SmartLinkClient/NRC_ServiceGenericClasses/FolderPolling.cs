using Microsoft.VisualBasic;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.IO;
using Utilities;

//********************************************************************'
// Created by Elibad - 04/11/2007
//
//  These classes provide functionality to read the files that exist in a folder
//  with or without a filter, letting the developer loop through the files, 
//  read the properties and do other type of manipulations to the files within the folder
//*********************************************************************


namespace NRC.Miscellaneous.FolderPolling
{
    public class FileOperation : IDisposable
    {
        /// <param name="fileName">Name of the file to be used</param>
        /// <param name="mainDirectory">Path for the working Directory</param>
        /// <param name="errorDirectory">Path for the Error Directory</param>
        /// <param name="backupDirectory">Path for the Backup Directory</param>
        public FileOperation(string fileName, string mainDirectory = "", string errorDirectory = "C:\\NRC\\Errors", string backupDirectory = "C:\\NRC\\Backups", string backupFileName = "")
        {
            //Set values for Main variables
            if (File.Exists(fileName))
            {
                _sFileName = fileName;
                ValidFileName = true;
            }
            else
            {
                ValidFileName = false;
                throw new System.Exception("Invalid File Name" + Environment.NewLine + Environment.NewLine + "The File does not exist..." + Environment.NewLine + fileName);
            }
            BackupFileName = backupFileName;
            if (Directory.Exists(mainDirectory))
            {
                _sMainDirectory = mainDirectory;
            }
            else if (!string.IsNullOrEmpty(mainDirectory))
            {
                throw new System.Exception("Invalid Path for Main Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist..." + Environment.NewLine + mainDirectory);
            }

            if (Directory.Exists(errorDirectory))
            {
                _sErrorDirectory = errorDirectory;
            }
            else if (errorDirectory.ToLower() == "c:\\NRC\\errors")
            {
                Directory.CreateDirectory(errorDirectory);
                _sErrorDirectory = errorDirectory;
            }

            if (Directory.Exists(backupDirectory))
            {
                _sBackupDirectory = backupDirectory;
            }
            else if (backupDirectory.ToLower() == "c:\\NRC\\backups")
            {
                Directory.CreateDirectory(backupDirectory);
                _sBackupDirectory = backupDirectory;
            }

            // checks for invalid data on main variables
            if (_sMainDirectory != string.Empty)
            {
                MainDirDefined = true;
            }
            else
            {
                MainDirDefined = false;
            }
            if (_sBackupDirectory != string.Empty)
            {
                BackupFiles = true;
            }
            else
            {
                BackupFiles = false;
            }
            if (_sErrorDirectory != string.Empty)
            {
                ErrorFiles = true;
            }
            else
            {
                ErrorFiles = false;
            }

        }

        #region "Properties"
        /// <summary>
        /// This property shows the name and path of working file
        /// </summary>
        public string FullName
        {
            get { return _sFileName; }
            set
            {
                ValidFileName = false;
                if (DropBackup)
                {
                    DeleteBackup();
                }
                if (File.Exists(value))
                {
                    _sFileName = value;
                    BackupFileName = string.Empty;
                    if (_bAutomaticBackups)
                    {
                        Backup();
                    }
                    ValidFileName = true;
                }
                else if (value != string.Empty)
                {
                    throw new System.Exception("Invalid File Name" + Environment.NewLine + Environment.NewLine + "The File does not exist");
                }
            }
        }
        private string _sFileName = string.Empty;

        /// <summary>
        /// This property shows the name of backup file. This name will be auto generated by the class
        /// </summary>
        public string BackupFileName { get; private set; }

        /// <summary>
        /// This property shows just the file name
        /// </summary>
        public string FileName
        {
            get { return GetName(); }
        }

        /// <summary>
        /// This property shows just the file extension
        /// </summary>
        public string FileExtension
        {
            get { return GetExtension(); }
        }

        /// <summary>
        /// This property shows just the path location
        /// </summary>
        public string FilePath
        {
            get { return GetPath(); }
        }

        /// <summary>
        /// This property shows the Error Path folder.
        /// </summary>
        /// <remarks>If this property is not defined the path will default to "C:\NRC\Errors"</remarks>
        public string ErrorPath
        {
            get { return _sErrorDirectory; }
            set
            {
                if (Directory.Exists(value))
                {
                    _sErrorDirectory = value;
                    ErrorFiles = true;
                }
                else if (!string.IsNullOrEmpty(value))
                {
                    throw new System.Exception("Invalid Path for Error Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                }
            }
        }
        private string _sErrorDirectory = string.Empty;

        /// <summary>
        /// This property shows the Backup Path folder.
        /// </summary>
        /// <remarks>If this property is not defined the Backup path will default to "C:\NRC\backups"</remarks>
        public string BackupPath
        {
            get { return _sBackupDirectory; }
            set
            {
                if (Directory.Exists(value))
                {
                    _sBackupDirectory = value;
                    BackupFiles = true;
                }
                else if (!string.IsNullOrEmpty(value))
                {
                    throw new System.Exception("Invalid Path for Backup Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                }
            }
        }
        private string _sBackupDirectory = string.Empty;

        /// <summary>
        /// This property shows the path of the main folder
        /// </summary>
        /// <remarks>
        /// If defined the property sub path will be able to extract the sub folders after the Base path otherwise will sub path will return an empty string
        /// 
        /// Example:
        /// 
        /// Base Path: "C:\folder1"
        /// FullName: "C:\folder1\folder2\otherfolder\file1.txt
        /// 
        /// Sub path will be: "\folder2\otherfolder"
        /// </remarks>
        public string BasePath
        {
            get { return _sMainDirectory; }
            set
            {
                if (Directory.Exists(value))
                {
                    _sMainDirectory = value;
                    MainDirDefined = true;
                }
                else if (!string.IsNullOrEmpty(value))
                {
                    throw new System.Exception("Invalid Path for Base Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                }
            }
        }
        private string _sMainDirectory = string.Empty;

        /// <summary>
        /// This property shows the sub folder path
        /// </summary>
        /// <remarks>This property needs the property BasePath to be defined.</remarks>
        public string SubPath
        {
            get { return GetJustSubPath(); }
        }

        /// <summary>
        /// This property defines if the class should create an automatic backup of current file
        /// </summary>
        public bool AutomaticBackups
        {
            get { return _bAutomaticBackups; }
            set
            {
                _bAutomaticBackups = value;
                if (_bAutomaticBackups)
                {
                    Backup();
                }
            }
        }
        private bool _bAutomaticBackups;

        /// <summary>
        /// This property defines if the class should drop the backup files 
        /// after operation with current file has been completed
        /// </summary>
        public bool DropBackup { get; set; }
        public bool ValidFileName { get; private set; }
        public bool MainDirDefined { get; private set; }
        public bool BackupFiles { get; private set; }
        public bool ErrorFiles { get; private set; }
        public bool Disposed { get; private set; }


        #endregion

        #region "Methods"
        /// <summary>
        /// This Method obtains the extension of the current file
        /// </summary>
        private string GetExtension()
        {
            string functionReturnValue = null;
            functionReturnValue = string.Empty;
            if (ValidFileName)
            {
                functionReturnValue = GetExtension(_sFileName);
            }
            return functionReturnValue;
        }

        /// <summary>
        /// This Method obtains the extension of the file
        /// </summary>
        public string GetExtension(string FileName)
        {
            string functionReturnValue = null;
            int i = Strings.Len(FileName);
            string TheFileCharacter = null;
            functionReturnValue = string.Empty;
            for (i = Strings.Len(FileName); i >= 1; i += -1)
            {
                TheFileCharacter = Strings.Mid(FileName, i, 1);
                if (TheFileCharacter != ".")
                {
                    functionReturnValue = TheFileCharacter + functionReturnValue;
                }
                else
                {
                    i = 1;
                }
            }

            //adds an unknown file extension to files that come in without extension
            if (functionReturnValue == FileName)
            {
                functionReturnValue = "unknown";
            }
            return functionReturnValue;

        }

        /// <summary>
        /// This Method checks if the current file has exclusive access
        /// </summary>
        public bool HasExclusiveAccess(int WaitInSeconds)
        {
            //Checks to see if no other application is using the file before performing
            //any operations on it. Specifically when a file is still being copied over into the 
            //data directory.

            return HasExclusiveAccess(this._sFileName, WaitInSeconds);
        }


        /// <summary>
        /// This Method obtains just the path for the current file
        /// </summary>
        private string GetPath()
        {
            string functionReturnValue = null;
            functionReturnValue = string.Empty;
            if (ValidFileName)
            {
                functionReturnValue = Path.GetDirectoryName(_sFileName);
            }
            return functionReturnValue;
        }

        /// <summary>
        /// This Method obtains just the path for the current file
        /// </summary>
        public string GetPath(string FileName)
        {
            return Path.GetDirectoryName(FileName);
            //FileName.Substring(0, FileName.Length - My.Computer.FileSystem.GetName(FileName).Length);
        }

        /// <summary>
        /// This Method obtains just the file name of the current file
        /// </summary>
        private string GetName()
        {
            if (ValidFileName)
            {
                if (MainDirDefined && _sFileName.Trim().Length > 0)
                {
                    return Path.GetFileName(_sFileName);
                }
            }
            return string.Empty;
        }

        /// <summary>
        /// This Method obtains just the file name of the current file
        /// </summary>
        public string GetName(string FileName)
        {
            if (FileName.Trim().Length > 0)
            {
                return Path.GetFileName(FileName);
            }
            return string.Empty;
        }

        /// <summary>
        /// This Method deletes the current file
        /// </summary>
        public void Delete()
        {
            if (File.Exists(_sFileName))
            {
                try
                {
                    File.Delete(_sFileName);
                }
                catch (Exception ex)
                {
                    throw new Exception_PathNotFound(_sFileName, ex);
                }
            }
        }

        /// <summary>
        /// This Method deletes backup the current file
        /// </summary>
        public void DeleteBackup()
        {
            if (File.Exists(BackupFileName))
            {
                File.Delete(BackupFileName);
                BackupFileName = string.Empty;
            }
        }

        /// <summary>
        /// This Method creates a backup of the current file on the Backup Directory
        /// </summary>
        public void Backup()
        {
            string sNewFileName = null;
            //makes sure the backup can be done
            if (BackupFiles & _sBackupDirectory != string.Empty & MainDirDefined & BackupFileName == string.Empty & ValidFileName)
            {
                //creates an unique name for the backup file using date and time
                sNewFileName = GetName(_sFileName);
                if (Strings.Mid(sNewFileName, Strings.Len(sNewFileName) - 3, 1) == ".")
                {
                    sNewFileName = Strings.Left(sNewFileName, Strings.Len(sNewFileName) - 4) + "_" + DateTime.Now.ToString("yyyyMMdd_HHmmssfff") + Strings.Right(sNewFileName, 4);
                }
                File.Copy(_sFileName, _sBackupDirectory + "\\" + sNewFileName);
                BackupFileName = _sBackupDirectory + "\\" + sNewFileName;
            }
            else if (_sBackupDirectory == string.Empty & BackupFileName == string.Empty)
            {
                throw new System.Exception("Can not make backup of current file" + Environment.NewLine + Environment.NewLine + "The BackupPath needs to be declared");
            }
        }

        /// <summary>
        /// This Method moves the current file to the Error directory
        /// </summary>
        public void MoveToErrorFolder()
        {
            //makes sure the file can be moved to error directory
            if (ErrorFiles & ValidFileName)
            {
                Files.RenameFile(_sFileName, Path.Combine(_sErrorDirectory, Path.GetFileName(_sFileName)), true);
            }
            else if (!ErrorFiles)
            {
                throw new System.Exception("Can not move file to Error Folder" + Environment.NewLine + Environment.NewLine + "The ErrorPath needs to be declared");
            }
        }

        /// <summary>
        /// This Method restores current file from backup file
        /// </summary>
        public void RestoreFromBackup()
        {
            if (BackupFileName != string.Empty & ValidFileName)
            {
                File.Copy(BackupFileName, _sFileName, true);
            }
            else if (BackupFileName == string.Empty)
            {
                throw new System.Exception("Can not restore file" + Environment.NewLine + Environment.NewLine + "There is no backup for current file");
            }
        }


        /// <summary>
        /// This Methos obatins just the subdirectory path for the current path after the main Directory
        /// </summary>
        private string GetJustSubPath()
        {
            string functionReturnValue = null;
            functionReturnValue = string.Empty;
            if (ValidFileName)
            {
                if ((_sFileName.Length - Path.GetFileName(_sFileName).Length > _sMainDirectory.Length + 1))
                {
                    functionReturnValue = _sFileName.Substring(_sMainDirectory.Length + 1, _sFileName.Length - Path.GetFileName(_sFileName).Length - _sMainDirectory.Length - 1);
                }
                else
                {
                    functionReturnValue = "None";
                }
            }
            return functionReturnValue;
        }

        /// <summary>
        /// This method cleans the filename from any invalid characters
        /// </summary>
        public void CleanFileName()
        {
            // Clean the filename (Not sure why)
            if (ValidFileName)
            {
                string path = Path.GetDirectoryName(_sFileName);
                string fileName = Path.GetFileNameWithoutExtension(_sFileName);
                string ext = Path.GetExtension(_sFileName);

                fileName = Formatting.Replace(fileName, string.Empty, ".zip", "~", " ");
                while (fileName.EndsWith("."))
                {
                    fileName = fileName.Substring(0, fileName.Length - 1);
                }
                if (string.IsNullOrWhiteSpace(fileName))
                {
                    fileName = DateTime.Now.ToString("yyyy-MM-ddTHHmmss");
                }
                if (string.IsNullOrWhiteSpace(ext))
                {
                    ext = ".unknown";
                }

                // Rename this file
                Files.RenameFile(_sFileName, fileName + ext);
            }
        }

        /// <summary>
        /// This method creates a copy of the current object
        /// </summary>
        public FileOperation Copy()
        {
            return new FileOperation(this.FullName, this.FilePath, this.ErrorPath, this.BackupPath, this.BackupFileName);
        }

        protected virtual void dispose(bool disposing)
        {
            if (!this.Disposed)
            {
                if (disposing)
                {
                }
            }
            if (DropBackup)
            {
                DeleteBackup();
            }
            this.Disposed = true;
        }

        public static bool HasExclusiveAccess(string FileName, int WaitInSeconds)
        {
            //Checks to see if no other application is using the file before performing
            //any operations on it. Specifically when a file is still being copied over into the 
            //data directory.
            bool blnResult = false;
            int intTries = 0;

            FileInfo FI = null;

            blnResult = false;

            if (File.Exists(FileName))
            {
                FI = new FileInfo(FileName);
                if (FI.IsReadOnly)
                {
                    FI.Attributes = FileAttributes.Normal;
                }

                while (blnResult == false & intTries < WaitInSeconds)
                {
                    try
                    {
                        FileStream fs = new FileStream(FileName, FileMode.Append, FileAccess.Write, FileShare.None);
                        fs.Close();
                        blnResult = true;
                        break; // TODO: might not be correct. Was : Exit While
                    }
                    catch
                    {
                        blnResult = false;
                        intTries += 1;
                        System.Threading.Thread.Sleep(1000);
                    }
                }
            }
            else
            {
                throw new System.Exception("Invalid FileName" + Environment.NewLine + Environment.NewLine + "The current File does not exist");
            }
            return blnResult;
        }

        #endregion

        #region "IDisposable support"
        public void Dispose()
        {
            dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion

    }


    public class FolderPolling : IDisposable
    {
        #region "Private Variables"
        /// <summary>
        /// This field holds the working path
        /// </summary>
        private string _sMainDirectory = string.Empty;
        /// <summary>
        /// This field holds the current directory
        /// </summary>
        private string _sCurrentDirectory = string.Empty;
        /// <summary>
        /// This field holds the current file
        /// </summary>
        private FileOperation _foCurrentFile;
        /// <summary>
        /// This array holds a list of all directories within the working folder
        /// </summary>
        private string[] _sAllDirectories;
        /// <summary>
        /// This array holds a list of all files within the working folder
        /// </summary>
        private string[] _sAllFiles;
        /// <summary>
        /// This field holds the error path
        /// </summary>
        private string _sErrorDirectory = string.Empty;
        /// <summary>
        /// This field holds the backup path
        /// </summary>
        private string _sBackupDirectory = string.Empty;
        /// <summary>
        /// This field shows when backup directory has been defined
        /// </summary>
        private bool BackupFiles = false;
        /// <summary>
        /// This field shows when the main Directory has been defined
        /// </summary>
        private bool MainDirDefined = false;
        /// <summary>
        /// This field controls when the class should not preserve the backup file
        /// </summary>
        private bool _bDropBackup = false;
        /// <summary>
        /// This field controls when the class should look for files inside subdirectories
        /// </summary>
        private bool _bRecursive = false;
        /// <summary>
        /// This field holds an enumerator for all the subdirectories within the main directory
        /// </summary>
        private System.Collections.IEnumerator _enDirectories;
        /// <summary>
        /// This field holds an enumerator for all the files in Main Directory
        /// </summary>

        private System.Collections.IEnumerator _enFiles;
        /// <summary>
        /// This field knows when the class should make automatic backups of files
        /// </summary>
        private bool _bAutomaticBackups;
        /// <summary>
        /// This field manipulates the files within the subdirectory
        /// </summary>

        private FolderPolling _fpSubdirectory;

        protected bool disposed;
        private bool _bGetfiles;
        private string _sFilter = "*.*";

        private bool _bSubDirectoryUsed = false;
        #endregion

        #region "Constructor Methods"
        /// <param name="MainDirectory">Path to the Working Folder</param>
        public FolderPolling(string MainDirectory, bool Recursive = true)
        {
            InitializeVariables(MainDirectory, "", "", false, Recursive);
        }

        /// <param name="MainDirectory">Path to the Working Folder</param>
        /// <param name="ErrorDirectory">Path to the Error Folder</param>
        public FolderPolling(string MainDirectory, string ErrorDirectory, bool Recursive = true)
        {
            InitializeVariables(MainDirectory, ErrorDirectory, "", false, Recursive);
        }

        /// <param name="MainDirectory">Path to the Working Folder</param>
        /// <param name="ErrorDirectory">Path to the Error Folder</param>
        /// <param name="BackupDirectory">Path to the Backup Folder</param>
        /// <param name="AutomaticBackup">Optional - When true the class will create Automatic backups</param>
        public FolderPolling(string MainDirectory, string ErrorDirectory, string BackupDirectory, bool AutomaticBackup = false, bool Recursive = true)
        {
            InitializeVariables(MainDirectory, ErrorDirectory, BackupDirectory, AutomaticBackup, Recursive);
        }
        #endregion

        #region "Private Methods"
        /// <param name="MainDirectory">Path for the working Directory</param>
        /// <param name="ErrorDirectory">Path for the Error Directory</param>
        /// <param name="BackupDirectory">Path for the Backup Directory</param>
        /// <param name="AutomaticBackup">When true the class will create Automatic backups</param>

        private void InitializeVariables(string MainDirectory, string ErrorDirectory, string BackupDirectory, bool AutomaticBackup, bool Recursive)
        {
            //this is thrown only if needed
            Exception ex = null;

            //Set values for Main variables
            if (System.IO.Directory.Exists(MainDirectory))
            {
                _sMainDirectory = MainDirectory;
            }
            else
            {
                ex = new System.Exception("Invalid Path for Main Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                ex.Data.Add("FolderPolling::InitializeVariables::MainDirectory", MainDirectory);
                throw ex;
            }
            if (System.IO.Directory.Exists(ErrorDirectory))
            {
                _sErrorDirectory = ErrorDirectory;
            }
            else if (ErrorDirectory != string.Empty)
            {
                ex = new System.Exception("Invalid Path for Error Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                ex.Data.Add("FolderPolling::InitializeVariables::ErrorDirectory", ErrorDirectory);
                throw ex;
            }
            if (System.IO.Directory.Exists(BackupDirectory))
            {
                _sBackupDirectory = BackupDirectory;
            }
            else if (BackupDirectory != string.Empty)
            {
                ex = new System.Exception("Invalid Path for Backup Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                ex.Data.Add("FolderPolling::InitializeVariables::BackupDirectory", BackupDirectory);
                throw ex;
            }
            _bRecursive = Recursive;
            // checks for invalid data on main variables
            if (_sMainDirectory != string.Empty)
            {
                MainDirDefined = true;
            }
            else
            {
                MainDirDefined = false;
            }
            if (_sBackupDirectory != string.Empty)
            {
                BackupFiles = true;
            }
            else
            {
                BackupFiles = false;
            }
            if (MainDirDefined & BackupFiles)
            {
                _bAutomaticBackups = AutomaticBackup;
            }
            else
            {
                _bAutomaticBackups = false;
            }
        }

        /// <summary>
        /// This Method opens the main folder and grabs the first file
        /// </summary>
        private bool GetFiles()
        {
            bool functionReturnValue = false;
            bool bContinue = false;
            functionReturnValue = false;

            //Makes sure the Main directory has been defined
            if (MainDirDefined & !_bGetfiles)
            {
                _bGetfiles = true;
                _bSubDirectoryUsed = false;

                // reads the sub directories names
                try
                {
                    _sAllDirectories = System.IO.Directory.GetDirectories(_sMainDirectory);
                }
                catch (Exception ex)
                {
                    Exception_PathNotFound pnf_ex = new Exception_PathNotFound(_sMainDirectory, ex);
                    ex.Data.Add("FolderPolling::GetFiles::MainDirectory", _sMainDirectory);
                    throw ex;
                }

                _enDirectories = _sAllDirectories.GetEnumerator();

                // makes sure there are subfolders
                if (_sAllDirectories.Length > 0 & _bRecursive)
                {
                    bContinue = true;
                    do
                    {
                        if (_enDirectories.MoveNext())
                        {
                            _sCurrentDirectory = _enDirectories.Current.ToString();
                            if (_fpSubdirectory == null)
                            {
                                _fpSubdirectory = new FolderPolling(_sCurrentDirectory, _sErrorDirectory, _sBackupDirectory, _bAutomaticBackups, _bRecursive);
                            }
                            else
                            {
                                _fpSubdirectory.Directory = _sCurrentDirectory;
                                _fpSubdirectory.ErrorDirectory = _sErrorDirectory;
                                _fpSubdirectory.BackupDirectory = _sBackupDirectory;
                                _fpSubdirectory.AutomaticBackups = _bAutomaticBackups;
                                _fpSubdirectory.Recursive = _bRecursive;
                            }
                            _fpSubdirectory.Filter = _sFilter;
                            _fpSubdirectory.DropBackup = _bDropBackup;
                        }
                        else
                        {
                            bContinue = false;
                        }
                    } while (!_fpSubdirectory.GetFiles() & bContinue);

                }
                else
                {
                    _enDirectories = null;
                }
                // reads the file names within the main folder
                try
                {
                    _sAllFiles = System.IO.Directory.GetFiles(_sMainDirectory, _sFilter);
                }
                catch (Exception ex)
                {
                    throw new Exception_PathNotFound(_sMainDirectory, ex);
                }
                _enFiles = _sAllFiles.GetEnumerator();
                //makes sure there are files
                if (_enFiles.MoveNext())
                {
                    if (_foCurrentFile == null)
                    {
                        _foCurrentFile = new FileOperation(_enFiles.Current.ToString(), _sMainDirectory, _sErrorDirectory, _sBackupDirectory);
                    }
                    else
                    {
                        _foCurrentFile.FullName = _enFiles.Current.ToString();
                        _foCurrentFile.BasePath = _sMainDirectory;
                        _foCurrentFile.ErrorPath = _sErrorDirectory;
                        _foCurrentFile.BackupPath = _sBackupDirectory;
                    }
                    _foCurrentFile.AutomaticBackups = _bAutomaticBackups;
                    _foCurrentFile.DropBackup = _bDropBackup;
                    _foCurrentFile.CleanFileName();
                }
                else
                {
                    if ((_foCurrentFile != null))
                    {
                        _foCurrentFile.Dispose();
                        _foCurrentFile = null;
                    }

                    this.NextFile();
                }
                if ((_foCurrentFile != null))
                {
                    functionReturnValue = true;
                }
            }
            return functionReturnValue;
        }

        public void DeleteFiles(bool Recursive)
        {
            string[] sAllDirectories = null;
            System.Collections.IEnumerator enListDirectories = null;
            string[] sFiles = null;
            System.Collections.IEnumerator enListFiles = null;

            try
            {
                sFiles = System.IO.Directory.GetFiles(_sMainDirectory);
            }
            catch (Exception ex)
            {
                throw new Exception_PathNotFound(_sMainDirectory, ex);
            }

            enListFiles = sFiles.GetEnumerator();

            while (enListFiles.MoveNext())
            {
                File.Delete(enListFiles.Current.ToString());
            }


            if (Recursive)
            {
                try
                {
                    sAllDirectories = System.IO.Directory.GetDirectories(_sMainDirectory);
                }
                catch (Exception ex)
                {
                    throw new Exception_PathNotFound(_sMainDirectory, ex);
                }

                enListDirectories = _sAllDirectories.GetEnumerator();
                while (enListDirectories.MoveNext())
                {
                    System.IO.Directory.Delete(enListDirectories.Current.ToString(), Recursive);
                }
            }

        }

        public void DeleteEmptyFolders(bool Recursive)
        {
            string[] sSubDirectories = null;
            System.Collections.IEnumerator enListDirectories = null;

            // Droping object variables
            if ((_fpSubdirectory != null))
            {
                _fpSubdirectory.dispose(true);
            }

            _fpSubdirectory = null;
            if ((_foCurrentFile != null))
            {
                _foCurrentFile.Dispose();
            }

            _foCurrentFile = null;
            _sAllDirectories = null;
            _sAllFiles = null;
            _enDirectories = null;
            _enFiles = null;


            // Delete folders

            if (Recursive)
            {
                try
                {
                    sSubDirectories = System.IO.Directory.GetDirectories(_sMainDirectory);
                }
                catch (Exception ex)
                {
                    throw new Exception_PathNotFound(_sMainDirectory, ex);
                }

                enListDirectories = sSubDirectories.GetEnumerator();

                if (sSubDirectories.Length > 0)
                {
                    while (enListDirectories.MoveNext())
                    {
                        DeleteFolder(enListDirectories.Current.ToString(), Recursive);
                    }
                }
            }

        }

        private void DeleteFolder(string Path, bool Recursive = false)
        {
            string[] sSubDirectories = null;
            System.Collections.IEnumerator enListDirectories = null;

            try
            {
                sSubDirectories = System.IO.Directory.GetDirectories(Path);
            }
            catch (Exception ex)
            {
                throw new Exception_PathNotFound(Path, ex);
            }

            enListDirectories = sSubDirectories.GetEnumerator();


            if (sSubDirectories.Length > 0 & Recursive)
            {
                while (enListDirectories.MoveNext())
                {
                    DeleteFolder(enListDirectories.Current.ToString(), Recursive);
                }
            }

            try
            {
                sSubDirectories = null;
                enListDirectories = null;
                GC.Collect();
                System.IO.Directory.Delete(Path);

            }
            catch
            {
            }
        }


        #endregion

        #region "Public Properties"
        /// <summary>
        /// This property defines if the class should drop the backup files 
        /// after operation with current file has been completed
        /// </summary>
        public bool DropBackup
        {
            get { return _bDropBackup; }
            set
            {
                _bDropBackup = value;
                if ((_foCurrentFile != null))
                {
                    _foCurrentFile.DropBackup = value;
                }
                if ((_fpSubdirectory != null))
                {
                    _fpSubdirectory.DropBackup = value;
                }
            }
        }

        /// <summary>
        /// This property defines the filter to be used while retrieving the files
        /// </summary>
        public string Filter
        {
            get { return _sFilter; }
            set
            {
                if (value == string.Empty)
                {
                    _sFilter = "*.*";
                }
                else
                {
                    _sFilter = value;
                }

                this.Directory = this.Directory;
            }
        }

        /// <summary>
        /// This property defines if the class should get files through the subdirectories
        /// </summary>
        public bool Recursive
        {
            get { return _bRecursive; }
            set
            {
                _bRecursive = value;
                if ((_fpSubdirectory != null))
                {
                    _fpSubdirectory.Recursive = value;
                }
                this._bGetfiles = false;
            }
        }
        /// <summary>
        /// This property defines if the class should create an automatic backup of current file
        /// </summary>
        public bool AutomaticBackups
        {
            get { return _bAutomaticBackups; }
            set
            {
                _bAutomaticBackups = value;
                if ((_foCurrentFile != null))
                {
                    _foCurrentFile.AutomaticBackups = value;
                }
                if ((_fpSubdirectory != null))
                {
                    _fpSubdirectory.AutomaticBackups = _bAutomaticBackups;
                }
            }
        }

        /// <summary>
        /// This property shows the working path
        /// </summary>
        public string Directory
        {
            get { return _sMainDirectory; }
            set
            {
                //makes sure is a valid path
                _bGetfiles = false;
                if ((_foCurrentFile != null))
                {
                    _foCurrentFile.FullName = "";
                }
                if ((_fpSubdirectory != null))
                {
                    _fpSubdirectory.dispose(true);
                    _fpSubdirectory = null;
                }
                if (value != string.Empty & System.IO.Directory.Exists(value))
                {
                    _sMainDirectory = value;
                    MainDirDefined = true;
                }
                else
                {
                    MainDirDefined = false;
                    throw new System.Exception("Invalid Path for Main Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                }
            }
        }

        /// <summary>
        /// This property shows the working file
        /// </summary>
        public FileOperation CurrentFile
        {
            get { return _foCurrentFile; }
        }

        /// <summary>
        /// This property shows the Error path
        /// </summary>
        public string ErrorDirectory
        {
            get { return _sErrorDirectory; }
            set
            {
                //makes sure is a valid path
                if (System.IO.Directory.Exists(value))
                {
                    _sErrorDirectory = value;
                    if ((_fpSubdirectory != null))
                    {
                        _fpSubdirectory.ErrorDirectory = value;
                    }
                    if ((_foCurrentFile != null))
                    {
                        _foCurrentFile.ErrorPath = value;
                    }
                }
                else if (value != string.Empty)
                {
                    throw new System.Exception("Invalid Path for Error Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                }
            }
        }

        /// <summary>
        /// This property shows the Backup path
        /// </summary>
        public string BackupDirectory
        {
            get { return _sBackupDirectory; }
            set
            {
                //makes sure is a valid path
                if (System.IO.Directory.Exists(value))
                {
                    _sBackupDirectory = value;
                    if ((_fpSubdirectory != null))
                    {
                        _fpSubdirectory.BackupDirectory = value;
                    }
                    if ((_foCurrentFile != null))
                    {
                        _foCurrentFile.BackupPath = value;
                    }
                    BackupFiles = true;
                }
                else if (value != string.Empty)
                {
                    BackupFiles = false;
                    throw new System.Exception("Invalid Path for Backup Directory" + Environment.NewLine + Environment.NewLine + "The Folder does not exist");
                }
            }
        }

        #endregion

        #region "Public methods"

        /// <summary>
        /// This Method select the next file in the list
        /// if recursive option is enabled will look for next file within subdirectories
        /// </summary>
        public bool NextFile()
        {
            bool functionReturnValue = false;
            string sNextFile = string.Empty;

            functionReturnValue = false;

            if (!_bGetfiles)
            {
                if (GetFiles())
                {
                    functionReturnValue = true;
                    return functionReturnValue;
                }
            }

            if (_enFiles == null)
            {
                return functionReturnValue;
            }

            if (_enFiles.MoveNext())
            {
                // if next file exists then grab file name
                sNextFile = _enFiles.Current.ToString();
                if (File.Exists(sNextFile))
                {
                    _foCurrentFile.FullName = _enFiles.Current.ToString();
                    _foCurrentFile.CleanFileName();
                }
                functionReturnValue = true;
                //if there is no file available on main directory take next file name from subdirectory
            }
            else if (_bRecursive & (_fpSubdirectory != null))
            {
                //if is the first time grab current filename
                if (!_bSubDirectoryUsed)
                {
                    _bSubDirectoryUsed = true;
                    if ((_fpSubdirectory.CurrentFile != null))
                    {
                        _foCurrentFile = _fpSubdirectory.CurrentFile.Copy();
                        sNextFile = _foCurrentFile.FullName;
                        if (!string.IsNullOrEmpty(_foCurrentFile.FullName))
                        {
                            functionReturnValue = true;
                        }
                    }
                    else if (_fpSubdirectory.NextFile())
                    {
                        _foCurrentFile = _fpSubdirectory.CurrentFile.Copy();
                        sNextFile = _foCurrentFile.FullName;
                        functionReturnValue = true;
                    }
                    else if (this.NextFile())
                    {
                        sNextFile = _foCurrentFile.FullName;
                        functionReturnValue = true;
                    }


                    // if not first time grab next filename
                }
                else if (_fpSubdirectory.NextFile())
                {
                    _foCurrentFile = _fpSubdirectory.CurrentFile.Copy();
                    sNextFile = _foCurrentFile.FullName;
                    functionReturnValue = true;

                    //if no more files move to next directory

                }
                else if ((_enDirectories != null) & (_fpSubdirectory != null))
                {
                    if (_enDirectories.MoveNext())
                    {
                        _fpSubdirectory.Directory = _enDirectories.Current.ToString();
                        _sCurrentDirectory = _enDirectories.Current.ToString();

                        if (_fpSubdirectory.GetFiles())
                        {
                            _foCurrentFile = _fpSubdirectory.CurrentFile.Copy();
                            sNextFile = _foCurrentFile.FullName;
                            functionReturnValue = true;
                        }
                    }
                }
            }

            if ((_foCurrentFile != null))
            {
                _foCurrentFile.BasePath = _sMainDirectory;
            }

            if (functionReturnValue)
            {
                if (!File.Exists(sNextFile))
                {
                    functionReturnValue = this.NextFile();
                }
            }
            return functionReturnValue;

        }


        #endregion

        #region "IDisposable Support"
        protected virtual void dispose(bool disposing)
        {
            if (!this.disposed)
            {
                if (disposing)
                {
                    if ((_foCurrentFile != null))
                    {
                        _foCurrentFile.Dispose();
                        _foCurrentFile = null;
                    }
                    if ((_fpSubdirectory != null))
                    {
                        _fpSubdirectory.dispose(true);
                        _fpSubdirectory = null;
                    }

                }
            }
            this.disposed = true;
        }


        public void Dispose()
        {
            dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion

    }
}

